打包原理？

如何写一个plugin

webpack 打包原理

使用generator 实现 aysnc await



前端长列表的性能优化

只渲染页面用用户能看到的部分。并且在不断滚动的过程中去除不在屏幕中的元素，不再渲染，从而实现高性能的列表渲染。

借鉴着这个想法，我们思考一下。当列表不断往下拉时，web中的dom元素就越多，即使这些dom元素已经离开了这个屏幕，不被用户所看到了，这些dom元素依然存在在那里。导致浏览器在渲染时需要不断去考虑这些dom元素的存在，造成web浏览器的长列表渲染非常低效。因此，实现的做法就是捕捉scroll事件，当dom离开屏幕，用户不再看到时，就将其移出dom tree。



单页面

​	快，不用刷新页面，每次返回的是一个页面，通过监听route 返回不同的代码块，

​	相对服务器压力小，没有页面切换，没有白屏阻塞

​	不利于SEO，首次加载消耗时长多



前端工程化

​	组件化，模块化 import, export，性能优化，部署，git

​	自动化测试，



loader 

​	语言转换工具，通过ast，进行文件转换，本质是一个function，传入的参数是source，

plugin

​	是一个类，通过webpack暴露的钩子，在对应的钩子上注册事件，然后等webpack生命周期到了，会执行注册的方法，发布订阅模式。常见的plugin， 什么 extractCssPlugin, ugligyjsPlugin 等

chunk

​	生成chunk的3种方式：异步代码会单独生成一个chunk，entry 会生成一个，splitChunks 会分割成，第三方chunk文件、组件chunk文件





**打包原理？**

webpack打包，最基本的实现方式，是将所有的模块代码放到一个数组里，通过数组ID来引用不同的模块

可以发现入口entry.js的代码是放在数组索引0的位置，其它a.js和b.js的代码分别放在了数组索引1和2的位置，而webpack引用的时候，主要通过__webpack_require__的方法引用不同索引的模块。

```
 ([
 function(module, exports, __webpack_require__) {
    __webpack_require__(1);
    __webpack_require__(2);
    console.log('Hello, world!');

},
/* 1 */
 function(module, exports) {

    var a = 'a.js';
    console.log("I'm a.js");

},
/* 2 */
function(module, exports) {

    var b = 'b.js';
    console.log("I'm b.js");

}
]);
```

webpack 和 gulp 区别？

​	一个是模块化打包工具，主要用于模块化，

​	gulp，一个是基于流的自动化构建工具，代替手工实现邹东华工作

webpack 打包过后，体积过大



虚拟dom:

作用：使用最小的代价更新dom

方式：使用js模拟真实dom，然后新旧dom进行比较，找出差异，再更新到真正的dom树上



vue是如何实现双向绑定的？

数据是如何和 view联系起来的？首先，我们通过 Object.defineProperty ，将vm的访问，进行监听, 当我们的页面编译成模板，返回的是模板函数，形式是with(this)，this 就是vm，执行，就将data数据挂载到dom上。

比如页面的input输入框，如果我们要修改input值，Viewmodel做的事情，就类似于，@input事件，view的数据变化会立即反应到model中。让文本框内容value = 改 vm 中对应data值，触发 set 方法，rerender，数据更新，视图更新



mixin 和 extend 区别

一个是不同的组件之间，复用。钩子函数，会合并，method， 两个对象健名相同，组件会覆盖

Vue.extend 是对单个实例进行扩展



Vue 虽然通过 v-model 支持双向绑定，但是如果引入了类似redux的vuex，就无法同时使用 v-model。

双绑跟单向绑定之间的差异只在于，双向绑定把数据变更的操作隐藏在框架内部，调用者并不会直接感知。

```
<input v-model="something">

<!-- 等价于以下内容 -->

<input :value="something" @input="something = $event.target.value">
```



路由

hash  和 history

window.onHashChange

history.pushState, history.replaceState ，改变hash 不会刷新页面



闭包

一般的变量，在函数执行完后会自动销毁，而闭包中的变量，因为有被闭包中的内部函数使用到，不会被垃圾回收机制回收，所以适合做，不污染全局变量的、常驻内存的变量



async 是 generator的语法糖，内部自执行，将 Generator 函数的星号（*）替换成 async，将 yield 替换成 await

async 有点：

1） Generator 函数必须靠执行器，所以才有CO函数库，async函数自带执行器 2）更好的语义 3）更广的适用性。co函数库yield后面只能是Thunk函数或者Promise对象，await后面可以跟Promise对象和原始类型值（等同于同步操作）



```
var o = new C()
Object.getPrototypeOf(o) === C.prototype
Object.getPrototypeOf(o) === o.__proto__
o instanceOf C

```



1. jsonp，只能get

2. document.domain 必须属于同一个基础域名!而且所用的协议，端口都要一致

比如我们要在当前页面下，`“www.sojson.com/shiro”` 下上传图片到 `"abc.www.sojson.com/images/"` 下去。直接搞肯定是不行的。

在请求`“www.sojson.com/shiro”` 的时候，写上如下代码：

```
if(document.domain !='sojson.com'){	document.domain = 'sojson.com';}
```

然后在上传的地址`“cdn.www.sojson.com”` 的`Iframe` 文件内写上一样的代码。

```
if(document.domain !='sojson.com'){	document.domain = 'sojson.com';}
```

这样上传就是在相同的域下了，有的人是少了第一步，其实仔细想想，正所谓跨域，就是指你使用功能的时候，当前域和使用的域不一样，所以要在前面就指定就可以了。故保证一致。

3. window.name 
4. html5， postMessage, iframe
5. cors



fetch:

浏览器新提供的api，支持promise 、async await