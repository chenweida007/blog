[中高级前端大厂面试秘籍，为你保驾护航金三银四，直通大厂(上)](https://juejin.im/post/5c64d15d6fb9a049d37f9c20)






### 1. 浏览器下事件循环(Event Loop)
事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表

	微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃)
	宏任务 macrotask(task): setTimout / script / IO / UI Rendering


### 2. 输入url过程干了什么

##### 2.1 DNS 的作用就是通过域名查询到具体的 IP。  

	操作系统会首先在本地缓存中查询 IP  
	没有的话会去系统配置的 DNS 服务器中查询   
	如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器    
	然后去该服务器查询 google 这个二级域名   
	接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP  


##### 2.2 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。



首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。

浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。

文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。

如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP/2 协议的话会极大的提高多图的下载效率。

CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西

在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。

这一部分就是渲染原理中讲解到的内容，可以详细的说明下这一过程。并且在下载文件时，也可以说下通过 HTTP/2 协议可以解决队头阻塞的问题。

总的来说这一章节就是带着大家从 DNS 查询开始到渲染出画面完整的了解一遍过程，将之前学习到的内容连接起来。

###3. 从输入 url 到展示的过程

DNS 解析
TCP 三次握手
发送请求，分析 url，设置请求报文(头，主体)
服务器返回请求的文件 (html)
浏览器渲染

HTML parser --> DOM Tree

标记化算法，进行元素状态的标记
dom 树构建


CSS parser --> Style Tree

解析 css 代码，生成样式树


attachment --> Render Tree

结合 dom树 与 style树，生成渲染树


layout: 布局
GPU painting: 像素绘制页面



### 4. http\https

HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。
在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。


对称加密：

对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。

这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。


非对称加密：

有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。

这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。

简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。




参考资料：  
[面试之道](https://juejin.im/book/5bdc715fe51d454e755f75ef/section/5bdc724af265da610f632e41)



### 5. 安全防范知识点

涉及面试题：什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP？

XSS 简单点来说，就是攻击者想尽一切办法<font color=" red" >  将可以执行的代码注入到网页中。</font>

XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。

持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。

举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容

非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。

举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行



转义字符   
首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义


js-xss



CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。


防范 CSRF 攻击可以遵循以下几种规则：


Get 请求不对数据进行修改  
不让第三方网站访问到用户 Cookie  
阻止第三方网站请求接口  
请求时附带验证信息，比如验证码或者 Token  
SameSite  
可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。  

验证 Referer   
对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。   

Token   
服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。   



### 6. V8垃圾回收机制
垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 新生代空间 和 老生代空间。

新生代空间: 用于存活较短的对象

又分成两个空间: from 空间 与 to 空间
Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法

存活的对象从 from space 转移到 to space
清空 from space
from space 与 to space 互换
完成一次新生代GC




老生代空间: 用于存活时间较长的对象

从 新生代空间 转移到 老生代空间 的条件

经历过一次以上 Scavenge GC 的对象
当 to space 体积超过25%


标记清除算法: 标记存活的对象，未被标记的则被释放

增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能
并发标记(最新技术): 不阻塞 js 执行


压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化

### 7. 内存泄露

意外的全局变量: 无法被回收
定时器: 未被正确关闭，导致所引用的外部变量无法被释放
事件监听: 没有正确销毁 (低版本浏览器可能出现)
闭包: 会导致父级中的变量无法被释放
dom 引用: dom 元素被删除时，内存中的引用未被正确清空

可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。

作者：郭东东
链接：https://juejin.im/post/5c64d15d6fb9a049d37f9c20
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


### 8. 浏览器缓存




强缓存，
强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200。

协商缓存  
如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。




缓存策略: 可分为 强缓存 和 协商缓存


Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires


当缓存已经过期时，使用协商缓存

唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改，
最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified)

如果一致，则直接返回 304 通知浏览器使用缓存
如不一致，则服务端返回新的资源





Last-Modified 缺点：

周期性修改，但内容未变时，会导致缓存失效
最小粒度只到 s， s 以内的改动无法检测到



Etag 的优先级高于 Last-Modified

### 9.介绍一下重绘和回流？需要怎么优化？

①用transform 代替 top，left ，margin-top， margin-left... 这些位移属性

② opacity 加上 transform: translateZ/3d  这个属性之后便不会发生回流和重绘了

③不要使用 js 代码对dom 元素设置多条样式，选择用一个 className 代替之。

④如果确实需要用 js 对 dom 设置多条样式那么可以将这个dom 先隐藏，然后再对其设置

⑤不要使用table 布局，因为table 的每一个行甚至每一个单元格的样式更新都会导致整个table 重新布局

⑥对于频繁变化的元素应该为其加一个 transform 属性，对于视频使用video 标签
