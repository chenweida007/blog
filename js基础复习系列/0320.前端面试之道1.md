5.加法规则  
在JavaScript中，加法的规则其实很简单，只有两种情况：  
1. 把数字和数字相加  
2. 把字符串和字符串相加  
所有其他类型的值都会被自动转换成这两种类型的值。  

规则：任意一方是字符串，另一方就会被转为字符串  
	  任意一方既不是字符串也不是数字，则这一方会转为原始类型(也就是数字或字符串)
	  
	  
	  

4.this放在谁的身上？ 
 
``` js

function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()

```

对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window  
对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象  
对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this


#### bind可以修改上下文，绑定一次上下文中this改成第一个参数，那么如果多次绑定呢？
```js

let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // => ?



// fn.bind().bind(a) 等于
let fn2 = function fn1() {
  return function() {
    return fn.apply()
  }.apply(a)
}
fn2();


let a = {}
let fn = function () { console.log(this) }

let fn2 = function fn1() {
  return function() {
    return fn.bind()
  }.bind(a)
}

```

this 的值与创建箭头函数的上下文的 this 一致。




#### bind和apply自己手写？




3. instanceof 原理  
a instance of b , 就是 a的原型链上，能否找到b  
 var str = 'hello world'  
str instanceof String // false

// str 不是对象，不能用 instanceof






2. null是对象么，不是对象的原因，什么情况导致了null判断为对象  
 	不是，typeof null 输出是 object  但是本身不是对象，早期js判断是否是对象的判断代码错误  
早期怎么判断的？  
早期js是  低位存储变量的类型信息，判断代码逻辑，低位以000为开头的就是对象，但是null都是0，所以判断是object


##### 1.看完了js基本类型，  
基本类型： undefined  null  boolean  string  number  symbol  
##### symbol的特点？
是一种新的基本数据类型，表示独一无二的值。symbol类型的值，可以通过Symbol函数生成，注意，不能通过new 生成  
写写 symbol的使用  
let a = Symbol("222");  
let b = Symbol("111");  
##### symbol作为属性怎么获取  
作为属性，该属性不会出现在 for...in 、for...of 循环中，也不会被 Object.keys() 、Object.getOwnPropertyName()、 JSON.stringify()返回。但是它也不是私有属性，有一个Object.getOwnPropertySymbols() 方法，返回一个数组，值是所有Symbol属性值


