内容包括   
1.reflect  
2. proxy  
3. promise  
4. iterator  
5. generator  
6. class  
7. module  





#### 2. proxy



#### 1.reflect
reflectz作用：

1.  代替Object 操作属性  
将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上

2.修改某些Object方法的返回结果，让其变得更合理  
Object.defineProperty(obj, name, desc)  
Reflect.defineProperty(obj, name, desc)


3.让Object操作都变成函数行为  
name in obj和delete obj[name]

Reflect.has(obj, name)  
Reflect.deleteProperty(obj, name)


4.Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法






<font color="red">Reflect.get(target, name, receiver)  </font>  
Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined  
如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。

<font color="red">
Reflect.set(target, name, value, receiver)  </font>  
Reflect.set方法设置target对象的name属性等于value。  
如果name属性设置了赋值函数，则赋值函数的this绑定receiver。  

```
let p = {
  a: 'a'
};

let handler = {
  set(target, key, value, receiver) {
    console.log('set');
    Reflect.set(target, key, value, receiver)
  },
  defineProperty(target, key, attribute) {
    console.log('defineProperty');
    Reflect.defineProperty(target, key, attribute);
  }
};

let obj = new Proxy(p, handler);
obj.a = 'A';
// set
// defineProperty
```

上面代码中，Proxy.set拦截里面使用了Reflect.set，而且传入了receiver，导致触发Proxy.defineProperty拦截。这是因为Proxy.set的receiver参数总是指向当前的 Proxy实例（即上例的obj），而Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。如果Reflect.set没有传入receiver，那么就不会触发defineProperty拦截。





<font color="red">Reflect.has(obj, name)  </font>  
Reflect.has方法对应name in obj里面的in运算符。



<font color="red">Reflect.deleteProperty(obj, name)</font>  
Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。


<font color="red">Reflect.getPrototypeOf(obj)</font>  
Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。





<font color="red">Reflect.setPrototypeOf(obj, newProto)</font>
Reflect.setPrototypeOf方法用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。




<font color="red">Reflect.apply(func, thisArg, args)</font>  
Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。



一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。

































